<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Bash is a thought pattern</title><meta name=author content><meta name=generator content="Hugo 0.62.2"><link rel=alternate href=https://blog.nukemberg.com/index.xml type=application/rss+xml title="Temporary heresy"><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css><link rel=stylesheet href=https://blog.nukemberg.com/css/bootstrap.min.css><link rel=stylesheet href=https://blog.nukemberg.com/css/main.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://blog.nukemberg.com/css/pygment_highlights.css><meta property="og:title" content="Bash is a thought pattern"><meta property="og:type" content="website"><meta property="og:url" content="/post/bash-is-a-thought-pattern//"><meta property="og:image" content="img/gorilla.jpg"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://blog.nukemberg.com/>Temporary heresy</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title="Blog posts" href=/>Blog posts</a></li><li><a title="About me" href=/page/about/>About me</a></li><li><a title=Presentations/Lectures href=/presentation/>Presentations/Lectures</a></li><li><a title="Reading list" href=/book/>Reading list</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Temporary heresy" href=https://blog.nukemberg.com/><img class=avatar-img src=https://blog.nukemberg.com/img/gorilla.jpg alt="Temporary heresy"></a></div></div></div></nav><div role=main class="container main-content"><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Bash is a thought pattern</h1><span class=post-meta>Posted on February 26, 2016</span></div></div></div></div></div></header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps movements are promoting. I often wonder why it so hard for some of them to learn the &ldquo;new ways&rdquo;. I've heard many people comment (often disrespectfully) that these difficulties are due to lack of &ldquo;technical skills&rdquo; - frequently citing poor programming abilities. While I agree this may be a real problem for <em>some</em> people, this explanation is far from being sufficient.</p><p>Sysadmins of old have traditionally used tools of great complexity and power, so much so that ordinary developers feared to wield them. I have met many developers that still refuse to touch &ldquo;Ops tools&rdquo; or production systems because they feel the tools would run amok. Surely the people that tamed such power possess significant technical skills. We must look for another explanation.</p><p>I believe the deeper explanation lies in the tools and work processes of the sysadmin profession. We must understand the world in which they live and work in and how they think about systems. In this sense, Bash is not a scripting language nor a shell; it is a thought pattern that we need to understand.</p><h2 id=the-bash-world>The Bash world</h2><p>In the &ldquo;programming&rdquo; world, we are used to thinking of basic constructs out of which we compose our programs. These constructs can be either intrinsic statements or expressions made of variables and values. Every statement has one input - a set of arguments; every expression has an input (again, a set of arguments) and an output that we can assign to a variable. From these Lego parts, we construct <em>functions</em> which are used in statements and expressions. A function has an input (a set of parameters) and an output - its return value. Sometimes, we add another form of output known as an <em>exception</em> - which cannot be understood without a clear concept of <em>scope</em>. We divide our toolchain to &ldquo;runtime&rdquo;, &ldquo;libraries&rdquo; and &ldquo;modules&rdquo;. The runtime is often regarded as magic - we simply believe it works and don't look too deeply into its guts, but libraries and modules are ours to write, read and use frequently. They are often written in the same language we use and follow the same principles.
In the programming world, we have APIs - sets of functions and data structures that together create an interface.</p><p>In the Bash world, on the other hand, functions and commands do not have a single input and output - instead they have several. A Bash function can have a set of arguments but can also have an input channel known as <em>stdin</em>. On the output side, Bash functions have 3 outputs - the return value, <em>stdout</em> and <em>stderr</em>. In Bash we do not have exceptions because the concept of <em>scope</em> is not well defined, again we have several intertwined pseudo scopes: environment variables, Bash variables, subshells, blocks, local and global variables and so on. Instead of dividing our world into libraries and modules, we have Bash built-ins and program binaries, both of which are regarded as magic and written in a non Bash language. Bash does have libraries but they are not used very often.
In the Bash world, we don't have APIs, instead we have filesystems - a set of files and various file syntaxes that together create an interface through which we can manipulate the world.</p><p>Clearly then, a Bash programmer thinks very differently from a Python or Ruby programmer.</p><h2 id=the-production-world>The production world</h2><p>Sysadmins do not write tests. This may seem reckless but is the result of their unique experience with complex production systems. Experience has taught sysadmins that the value of tests in those systems is very small and is most often not worth the effort.
Why is the value of tests small? In order to write meaningful tests, the system must be deterministic and we must be able to control all its inputs. In addition, we must also be able to capture all parts of the system's output and be able to compare it with the &ldquo;expected&rdquo; output of the test. In programming parlance, we say that we are either testing &ldquo;pure functions&rdquo; or that we mock and stub whatever components the functions being tested interact with.
This is simply not possible in complex production systems. Just as &ldquo;pure functions&rdquo; exist only in theory (every function has at least the side effect of consuming CPU time), so do &ldquo;stateless services&rdquo; exist only as a figment of imagination - there is always some state somewhere. But unlike &ldquo;pure functions&rdquo; whose side effects can be neglected for our purposes, the state and interactions of &ldquo;stateless&rdquo; services cannot be ignored so simply. And to make matters worse, we can't stub and mock the components used by the process under test - either because we don't even know what it's using or because mocking would cause the test to be meaningless. Think about a database backup process - if we mock the database, what is the point of our test?</p><p>In recent years, this problem is encountered by programmers more often, as the systems they work on become more and more complex and stateful. Most programmers however, spend the majority of their time working with systems that are reasonably testable.</p><h2 id=the-manual-labor-world>The manual labor world</h2><p>The sysadmin profession is characterized by &ldquo;manual labor&rdquo; - tasks that were designed to be carried out by human operators. Often, a sysadmin would not agree with the ideas of system designers on what should be automated and what should be left for human operator and would automate parts of the system using scripts. In the absence of proper APIs (mostly due to the designers&rsquo; notion that this doesn't need to be automated) sysadmins used &ldquo;virtual human&rdquo; tools for automation: <code>yes |</code>, text parsing and the notorious <code>expect</code>.</p><p>What differentiates programming from &ldquo;automation&rdquo; is this notion of a &ldquo;virtual human&rdquo; manipulating the world. The absence of APIs and focus on side effects (as opposed to data transformations) makes the automation code hard (if not impossible) to check and test. The wide variety of output signals makes it impossible to capture all error conditions and outputs, so error handling is often ignored completely.</p><p>The obvious solution would be to stick APIs everywhere and write proper software to manipulate our systems. Unfortunately, the difference between APIs and UIs is bigger than just the medium of communications - the semantics and even primitive concepts are very different - because computers and humans don't behave in a similar manner. For example, it makes sense to have a notification API fire a 100 messages per minute, but no human can cope with such a notification rate. We are forced to build yet another layer of human control software on top and push the operator interface/automation problem upwards in the stack.</p><h2 id=the-black-box>The black box</h2><p>Sysadmins (and operators in general) primarily deal with &ldquo;black boxes&rdquo; - systems whose internal structure and state is obscure. This can be the result of the system being designed and built by another group (perhaps vendor) or simply due to not having the time needed to learn the internals of the system. Sysadmins often deal with a large number of systems such that it's infeasible to learn all of them to an expert level. It's not uncommon to have a single person in charge of: MongoDB, MySQL, Linux, ElasticSearch, Apache, HAProxy, Consul, Tomcat and RabbitMQ - and you could spend months if not years mastering even one of these.</p><p>This &ldquo;black box&rdquo; view, when carried to its extreme (actually quite common in enterprises) assumes that we cannot change the box at all. If there are bugs, we will work around them. If the interface is hard to work with, we will wrap it. If it crashes, we will reboot it.</p><h1 id=an-unsure-future>An unsure future</h1><p>Can sysadmins learn the programmer's way of looking at the world? Can they master the concepts that power the software engineering discipline? Can they learn to think in terms of logic and APIs, of artifacts and libraries, of well defined and (relatively) predictable and testable components? I hope so.</p><p>Can programmers learn the sysadmin way of thinking? Can they master the concepts that describe a world of complexity and constant flux? Adapt to this world in which the dynamics of the system are stronger than the individual behavior of components, where nothing is well defined and flexibility is everything? Again, I hope so.</p><p>I believe we should learn from both disciplines and let ourselves be convinced by one another. In an industry that invents new technologies at a staggering rate, we simply don't have the time to wait for the old generation to die and for another to grow up.</p></article><ul class="pager blog-pager"><li class=previous><a href=https://blog.nukemberg.com/post/sw-dev-managment/ data-toggle=tooltip data-placement=top title="The most important principle of managing a software organization">&larr; Previous Post</a></li><li class=next><a href=https://blog.nukemberg.com/post/the-ironies-of-reliability/ data-toggle=tooltip data-placement=top title="The Ironies of Reliability">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"blog-sys-notes"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://blog.nukemberg.com/index.xml title=RSS><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">&nbsp;&bull;&nbsp;
2019
&nbsp;&bull;&nbsp;
<a href=https://blog.nukemberg.com/>Temporary heresy</a></p><p class="theme-by text-muted">Theme by
<a href=http://deanattali.com/beautiful-jekyll/>beautiful-jekyll</a></p></div></div></div></footer><script src=https://blog.nukemberg.com/js/jquery-1.11.2.min.js></script><script src=https://blog.nukemberg.com/js/bootstrap.min.js></script><script src=https://blog.nukemberg.com/js/main.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-78770646-1','auto');ga('send','pageview');}</script></body></html>