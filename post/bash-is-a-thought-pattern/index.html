<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Bash is a thought pattern - The Nukemblog</title><meta name=description content="As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps movements are promoting. I often wonder why it so hard for some of them to learn the &ldquo;new ways&rdquo;. I&rsquo;ve heard many people comment (often disrespectfully) that these difficulties are due to lack of &ldquo;technical skills&rdquo; - frequently citing poor programming abilities. While I agree this may be a real problem for some people, this explanation is far from being sufficient."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"The Nukemblog","url":"https:\/\/blog.nukemberg.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/blog.nukemberg.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/blog.nukemberg.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/blog.nukemberg.com\/post\/bash-is-a-thought-pattern\/","name":"Bash is a thought pattern"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"Bash is a thought pattern","description":"As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps movements are promoting. I often wonder why it so hard for some of them to learn the \u0026ldquo;new ways\u0026rdquo;. I\u0026rsquo;ve heard many people comment (often disrespectfully) that these difficulties are due to lack of \u0026ldquo;technical skills\u0026rdquo; - frequently citing poor programming abilities. While I agree this may be a real problem for some people, this explanation is far from being sufficient.\n","inLanguage":"en","wordCount":1459,"datePublished":"2016-02-26T00:38:42","dateModified":"2016-02-26T00:38:42","image":"https:\/\/blog.nukemberg.com\/img\/gorilla-small.png","keywords":["DevOps, software engineering"],"mainEntityOfPage":"https:\/\/blog.nukemberg.com\/post\/bash-is-a-thought-pattern\/","publisher":{"@type":"Organization","name":"https:\/\/blog.nukemberg.com\/","logo":{"@type":"ImageObject","url":"https:\/\/blog.nukemberg.com\/img\/gorilla-small.png","height":60,"width":60}}}</script><meta property="og:title" content="Bash is a thought pattern"><meta property="og:description" content="As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps movements are promoting. I often wonder why it so hard for some of them to learn the &ldquo;new ways&rdquo;. I&rsquo;ve heard many people comment (often disrespectfully) that these difficulties are due to lack of &ldquo;technical skills&rdquo; - frequently citing poor programming abilities. While I agree this may be a real problem for some people, this explanation is far from being sufficient."><meta property="og:image" content="https://blog.nukemberg.com/img/gorilla-small.png"><meta property="og:url" content="https://blog.nukemberg.com/post/bash-is-a-thought-pattern/"><meta property="og:type" content="website"><meta property="og:site_name" content="The Nukemblog"><meta name=twitter:title content="Bash is a thought pattern"><meta name=twitter:description content="As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps â€¦</!-->"><meta name=twitter:image content="https://blog.nukemberg.com/img/gorilla-small.png"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><link rel=alternate href=https://blog.nukemberg.com/index.xml type=application/rss+xml title="The Nukemblog"><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js integrity=sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body);></script><link rel=stylesheet href=https://blog.nukemberg.com/css/main.css><link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/styles/default.min.css><script defer src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js onload=hljs.highlightAll();></script><link rel=stylesheet href=https://blog.nukemberg.com/css/codeblock.css><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-78770646-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class="navbar navbar-custom navbar-expand-lg navbar-expand-md navbar-light bg-light"><div class=container-fluid><div class="avatar-container px-3"><div class=avatar-img-border><img src=https://blog.nukemberg.com/img/gorilla-small.png alt="The Nukemblog"></div></div><div class=navbar-header><a class=navbar-brand href=https://blog.nukemberg.com/>The Nukemblog</a>
<button type=button class=navbar-toggler data-bs-toggle=collapse data-bs-target=#main-navbar>
<span class=navbar-toggler-icon></span></button></div><div class="collapse navbar-collapse text-center" id=main-navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link title=Doctrines href=/post/>Doctrines</a></li><li class=nav-item><a class=nav-link title="About me" href=/page/about/>About me</a></li><li class=nav-item><a class=nav-link title=Lores href=/project/>Lores</a></li><li class=nav-item><a class=nav-link title=Scriptures href=/book/>Scriptures</a></li><li class=nav-item><a class=nav-link title=Sermons href=/presentation/>Sermons</a></li></ul></div></div></nav><header class=header-section><div class="intro-header no-img"><div class=container><div class="row py-2"><div class="col-10 offset-1"><div class=post-heading><h1>Bash is a thought pattern</h1><hr class=small></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-10 offset-1"><article role=main class=blog-post><p>As I became more involved in workshops and training, I observed many people coming from old-school sysadmin backgrounds struggle with the moderns tools and methodologies that the SRE and DevOps movements are promoting. I often wonder why it so hard for some of them to learn the &ldquo;new ways&rdquo;. I&rsquo;ve heard many people comment (often disrespectfully) that these difficulties are due to lack of &ldquo;technical skills&rdquo; - frequently citing poor programming abilities. While I agree this may be a real problem for <em>some</em> people, this explanation is far from being sufficient.</p><p>Sysadmins of old have traditionally used tools of great complexity and power, so much so that ordinary developers feared to wield them. I have met many developers that still refuse to touch &ldquo;Ops tools&rdquo; or production systems because they feel the tools would run amok. Surely the people that tamed such power possess significant technical skills. We must look for another explanation.</p><p>I believe the deeper explanation lies in the tools and work processes of the sysadmin profession. We must understand the world in which they live and work in and how they think about systems. In this sense, Bash is not a scripting language nor a shell; it is a thought pattern that we need to understand.</p><h2 id=the-bash-world>The Bash world</h2><p>In the &ldquo;programming&rdquo; world, we are used to thinking of basic constructs out of which we compose our programs. These constructs can be either intrinsic statements or expressions made of variables and values. Every statement has one input - a set of arguments; every expression has an input (again, a set of arguments) and an output that we can assign to a variable. From these Lego parts, we construct <em>functions</em> which are used in statements and expressions. A function has an input (a set of parameters) and an output - its return value. Sometimes, we add another form of output known as an <em>exception</em> - which cannot be understood without a clear concept of <em>scope</em>. We divide our toolchain to &ldquo;runtime&rdquo;, &ldquo;libraries&rdquo; and &ldquo;modules&rdquo;. The runtime is often regarded as magic - we simply believe it works and don&rsquo;t look too deeply into its guts, but libraries and modules are ours to write, read and use frequently. They are often written in the same language we use and follow the same principles.
In the programming world, we have APIs - sets of functions and data structures that together create an interface.</p><p>In the Bash world, on the other hand, functions and commands do not have a single input and output - instead they have several. A Bash function can have a set of arguments but can also have an input channel known as <em>stdin</em>. On the output side, Bash functions have 3 outputs - the return value, <em>stdout</em> and <em>stderr</em>. In Bash we do not have exceptions because the concept of <em>scope</em> is not well defined, again we have several intertwined pseudo scopes: environment variables, Bash variables, subshells, blocks, local and global variables and so on. Instead of dividing our world into libraries and modules, we have Bash built-ins and program binaries, both of which are regarded as magic and written in a non Bash language. Bash does have libraries but they are not used very often.
In the Bash world, we don&rsquo;t have APIs, instead we have filesystems - a set of files and various file syntaxes that together create an interface through which we can manipulate the world.</p><p>Clearly then, a Bash programmer thinks very differently from a Python or Ruby programmer.</p><h2 id=the-production-world>The production world</h2><p>Sysadmins do not write tests. This may seem reckless but is the result of their unique experience with complex production systems. Experience has taught sysadmins that the value of tests in those systems is very small and is most often not worth the effort.
Why is the value of tests small? In order to write meaningful tests, the system must be deterministic and we must be able to control all its inputs. In addition, we must also be able to capture all parts of the system&rsquo;s output and be able to compare it with the &ldquo;expected&rdquo; output of the test. In programming parlance, we say that we are either testing &ldquo;pure functions&rdquo; or that we mock and stub whatever components the functions being tested interact with.
This is simply not possible in complex production systems. Just as &ldquo;pure functions&rdquo; exist only in theory (every function has at least the side effect of consuming CPU time), so do &ldquo;stateless services&rdquo; exist only as a figment of imagination - there is always some state somewhere. But unlike &ldquo;pure functions&rdquo; whose side effects can be neglected for our purposes, the state and interactions of &ldquo;stateless&rdquo; services cannot be ignored so simply. And to make matters worse, we can&rsquo;t stub and mock the components used by the process under test - either because we don&rsquo;t even know what it&rsquo;s using or because mocking would cause the test to be meaningless. Think about a database backup process - if we mock the database, what is the point of our test?</p><p>In recent years, this problem is encountered by programmers more often, as the systems they work on become more and more complex and stateful. Most programmers however, spend the majority of their time working with systems that are reasonably testable.</p><h2 id=the-manual-labor-world>The manual labor world</h2><p>The sysadmin profession is characterized by &ldquo;manual labor&rdquo; - tasks that were designed to be carried out by human operators. Often, a sysadmin would not agree with the ideas of system designers on what should be automated and what should be left for human operator and would automate parts of the system using scripts. In the absence of proper APIs (mostly due to the designers&rsquo; notion that this doesn&rsquo;t need to be automated) sysadmins used &ldquo;virtual human&rdquo; tools for automation: <code>yes |</code>, text parsing and the notorious <code>expect</code>.</p><p>What differentiates programming from &ldquo;automation&rdquo; is this notion of a &ldquo;virtual human&rdquo; manipulating the world. The absence of APIs and focus on side effects (as opposed to data transformations) makes the automation code hard (if not impossible) to check and test. The wide variety of output signals makes it impossible to capture all error conditions and outputs, so error handling is often ignored completely.</p><p>The obvious solution would be to stick APIs everywhere and write proper software to manipulate our systems. Unfortunately, the difference between APIs and UIs is bigger than just the medium of communications - the semantics and even primitive concepts are very different - because computers and humans don&rsquo;t behave in a similar manner. For example, it makes sense to have a notification API fire a 100 messages per minute, but no human can cope with such a notification rate. We are forced to build yet another layer of human control software on top and push the operator interface/automation problem upwards in the stack.</p><h2 id=the-black-box>The black box</h2><p>Sysadmins (and operators in general) primarily deal with &ldquo;black boxes&rdquo; - systems whose internal structure and state is obscure. This can be the result of the system being designed and built by another group (perhaps vendor) or simply due to not having the time needed to learn the internals of the system. Sysadmins often deal with a large number of systems such that it&rsquo;s infeasible to learn all of them to an expert level. It&rsquo;s not uncommon to have a single person in charge of: MongoDB, MySQL, Linux, ElasticSearch, Apache, HAProxy, Consul, Tomcat and RabbitMQ - and you could spend months if not years mastering even one of these.</p><p>This &ldquo;black box&rdquo; view, when carried to its extreme (actually quite common in enterprises) assumes that we cannot change the box at all. If there are bugs, we will work around them. If the interface is hard to work with, we will wrap it. If it crashes, we will reboot it.</p><h1 id=an-unsure-future>An unsure future</h1><p>Can sysadmins learn the programmer&rsquo;s way of looking at the world? Can they master the concepts that power the software engineering discipline? Can they learn to think in terms of logic and APIs, of artifacts and libraries, of well defined and (relatively) predictable and testable components? I hope so.</p><p>Can programmers learn the sysadmin way of thinking? Can they master the concepts that describe a world of complexity and constant flux? Adapt to this world in which the dynamics of the system are stronger than the individual behavior of components, where nothing is well defined and flexibility is everything? Again, I hope so.</p><p>I believe we should learn from both disciplines and let ourselves be convinced by one another. In an industry that invents new technologies at a staggering rate, we simply don&rsquo;t have the time to wait for the old generation to die and for another to grow up.</p><div class=blog-tags><a href=https://blog.nukemberg.com//tags/devops/>DevOps</a>&nbsp;
<a href=https://blog.nukemberg.com//tags/software-engineering/>software engineering</a>&nbsp;</div></article><div class="pager blog-pager"><span class=previous><a href=https://blog.nukemberg.com/post/sw-dev-managment/ data-toggle=tooltip data-placement=top title="The most important principle of managing a software organization"><i class="bi bi-chevron-left"></i>Previous post</a></span>
<span class=next><a href=https://blog.nukemberg.com/post/the-ironies-of-reliability/ data-toggle=tooltip data-placement=top title="The Ironies of Reliability">Next post<i class="bi bi-chevron-right"></i></a></span></div></div></div></div><footer class=footer-main><div class=container><div class=row><div class="col-lg-8 col-md-10"><div class="row py-1"></div><div class=row><p class="credits copyright text-muted">&nbsp;&copy;
2021
&nbsp;&nbsp;
<a href=https://blog.nukemberg.com/>The Nukemblog</a></p><p class="credits text-muted">Powered by <a href=https://gethugo.io/>Hugo</a></p></div></div></div></div></footer><script src=https://blog.nukemberg.com/js/main.js></script></body></html>